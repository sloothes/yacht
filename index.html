<!DOCTYPE html>
<html lang="en">
	<head>

		<title>Dream Yatch (alpha)</title>

		<meta charset="utf-8">
		<meta name="generator" content="Three.js Editor">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

		<link rel="stylesheet" href="/css/joystick.css">
		<link rel="stylesheet" href="/css/bootstrap.min.css">
		<link rel="stylesheet" href="/css/bootbox-dialoges.css">
		<link rel="stylesheet" href="/css/jcrop.css">

		<script src="/js/watch.js"></script>
		<script src="/js/Objectid.js"></script>
		<script src="/js/jquery.min.js"></script> 
		<script src="/js/system.min.js"></script>
		<script src="/js/signals.min.js"></script>
		<script src="/js/inflate.min.js"></script>
		<script src="/js/zangodb.min.js"></script>
		<script src="/js/bootstrap.min.js"></script>
		<script src="/js/hold-event.min.js"></script>
		<script src="/js/jcrop.js"></script>

		<style>

			body {
				margin: 0px;
				font-size: 13px;
				font-family: sans-serif;
				background-repeat: repeat;
				background-image: url("https://i.imgur.com/rnZZU0i.png") !important;
				overflow: hidden;
			}

			#loading-bar {
				width:100%;
				height:100%;
				top:0; left:0;
				position:fixed;
				display:flex;
				align-items:center;
				justify-content:center;
			}

			.middle > * {
				top:0; 
				left:0;
				right:0;
				bottom:0;
				margin:auto;
				position:absolute;
			}

			#joystick1 {
				right: calc(40px + 370px);
			}
			
			#jumpButton {
				right: calc(105px + 370px);
			}

			.btn-matcap,
			.btn-terrain {
				padding:0;
				float:left;
				width:55px;
				height:55px;
				border:1px solid;
				border-radius:4px;
				margin-right:4px;
				margin-bottom:4px;
				display:inline-block;
			}

			.btn-matcap + .btn-matcap,
			.btn-terrain + .btn-terrain {
				margin-right:4px;
			}

		</style>
	</head>

	<body ontouchstart="">

		<script src="/ecs/js/TabUI.js"></script>
		<script>
			const debugMode = true;
			const Signal = signals.Signal;
			document.body.appendChild( createSidePanel() );
		</script>

		<script src="/ecs/js/three.js"></script>
		<script src="/ecs/js/MeshWalk.js"></script>
		<script src="/ecs/js/UVsDebug.js"></script>
		<script src="/ecs/js/FBXLoader.js"></script>
		<script src="/ecs/js/VirtualInput.js"></script>
		<script src="/ecs/js/KeyboardState.js"></script>
		<script src="/ecs/js/EditorControls.js"></script>
		<script src="/ecs/js/camera-controls.js"></script>
		<script src="/ecs/js/SubdivisionModifier.js"></script>
		<script src="/ecs/js/three-pathfinding.umd.js"></script>
		<script src="/threejs/r96/examples/js/loaders/GLTFLoader.js"></script>
		<script src="/threejs/r96/examples/js/exporters/GLTFExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/STLExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/OBJExporter.js"></script>
		<script src="/threejs/r96/examples/js/exporters/ColladaExporter.js"></script>

		<script src="/three/Ocean_fft.js"></script>
		<script src="/three/MirrorRenderer.js"></script>
		<script src="/three/WaterMaterial.js"></script>
		<script src="/ecs/engine/core/helpers.js"></script>
		<script src="/ecs/engine/core/keyboard.js"></script>
		<script src="/ecs/engine/core/enviroment.js"></script>
		<script src="/ecs/engine/core/localPlayer.js"></script>
		<script src="/ecs/engine/core/cameraControls.js"></script>
		<script src="/ecs/engine/core/keyboardState.js"></script>
		<script src="/ecs/engine/core/keyInputControls.js"></script>
		<script src="/ecs/engine/core/joystickControls.js"></script>

		<script src="/yatch/editor/EntityManager.js"></script>
		<script src="/yatch/editor/MaterialManager.js"></script>
		<script src="/yatch/editor/TexturesManager.js"></script>
		<script src="/yatch/editor/helpers.js"></script>
		<script src="/yatch/editor/UndoArray.js"></script>
		<script	src="/yatch/editor/editor-tab-ui.js"></script>
		<script	src="/yatch/editor/geometry-tab-ui.js"></script>
		<script	src="/yatch/editor/material-tab-ui.js"></script>
		<script	src="/yatch/editor/textures-tab-ui.js"></script>

	<!-- script src="/yatch/editor/EditorTab.js"></script -->
	<!-- script src="/yatch/editor/MaterialTab.js"></script -->
	<!-- script src="/yatch/editor/TexturesTab.js"></script -->


		<script>

		//	entity-droplist.js

		//	Last editor entity droplist value.
		//	keeps track of last entity droplist value.
			const latestEntityId = { value:"" };
		//	keeps entity's droplist last value.
			(function( latestEntityId,entity_droplist ){

			//	when you call lastEntity watcher you can get the old value.
				watch( latestEntityId, "value", function(property, action, newValue, oldValue ){
					debugMode && console.log({item:latestEntityId,"new value":newValue,"old value":oldValue})
				});

			//	Update latest entity id value.
				watch(entity_droplist, "onchange", function( property, event, value ){
					latestEntityId.value = value;
				});

			})( latestEntityId, document.querySelector("select#editor-entities-droplist") ); // entity_droplist.

		//	Update object editor.

			(function(editor,last_entity,cameraControls,localPlayer,keyInputControls,entity_droplist){

			//	CameraControls rigid objects,
			//	keeps camera controls rigid objects at edit mode.
				const rigidObjects = []; // cameraControls.rigidObjects;

			//	Exit from edit mode.

				function resetLatestEntityValue(){
					entity_droplist.value = "";
				}

				function enableKeyInputControls(){
					keyInputControls.isDisabled = false;
				}

				function disableKeyInputControls(){
					keyInputControls.isDisabled = true;
				}

				function takeCameraControls( object, offset ){
					cameraControls.trackObject = object;
					cameraControls.offset.y = offset || 0;
				}

				function enableCameraRigidObjects(){
					while (rigidObjects.length) {
						var object = rigidObjects.shift();
						object.isMesh && cameraControls.rigidObjects.push( object ); // cleanup.
					}
				}

				function disableCameraRigidObjects(){
					while (cameraControls.rigidObjects.length) {
						var object = cameraControls.rigidObjects.shift()
						object.isMesh && rigidObjects.push( object ); // cleanup.
					}
				}

				function exitFromEditMode(){
					editor.reset(); // important!
					resetLatestEntityValue();
					enableKeyInputControls();
					enableCameraRigidObjects();
					takeCameraControls( localPlayer );
					return;
				}

			//

				watch(entity_droplist, "onchange", function( property, event, value ){

					if ( editor.update( value ) ) {

					//	switchToEditMode.

						var object = getObjectByEntityId( value );
						if ( !object ) return exitFromEditMode();

					//	camera controls offset.
						if ( object.geometry && object.geometry.boundingSphere ) {
							var offset = object.geometry.boundingSphere.center;
							cameraControls.offset.copy( offset ); 
							cameraControls.offset.y *= 0.5;
						}

					//	Disable camera rigid objects.
						disableCameraRigidObjects();

					//	editor take camera controls.
						cameraControls.trackObject = editor; // or object?

					//	Disable key input controls.
						disableKeyInputControls(); // important!

					} else {

						exitFromEditMode();

					}

				});

			})(
				objectEditor, latestEntityId, cameraControls, localPlayer, keyInputControls, 
				document.querySelector("select#editor-entities-droplist") // entity_droplist.
			);

		//	Call vector droplist watchers.

			(function(vector_droplist,entity_droplist){

				watch(entity_droplist, "onchange", function( property, event, value ){
					try { callWatchers( vector_droplist, "onchange", "change", vector_droplist.value ); } 
					catch(err){ console.error(err); }
				});

			})(
				document.querySelector("select#editor-vector-droplist"), // vector_droplist.
				document.querySelector("select#editor-entities-droplist") // entity_droplist.
			);

		//	Call material entity droplist.

			(function(entity_droplist){

				watch(entity_droplist, "onchange", function( property, event, value ){

					try {

					//	Get material entities droplist.
						var selector = "select#material-entities-droplist";
						var material_droplist = document.querySelector(selector); if (!material_droplist) return;

					//	Get material id.
						var object = getObjectByEntityId( value ); if ( !object ) {
							return callWatchers( material_droplist, "onchange", "change", material_droplist.value = "" );
						}

						var material = object.material; if (!object.material) {
							return callWatchers( material_droplist, "onchange", "change", material_droplist.value = "" );
						}

						material && callWatchers( material_droplist, "onchange", "change", material_droplist.value = String(material.id) );

					} catch(err){ console.error(err); }
				});

			})( document.querySelector("select#editor-entities-droplist") ); // entity_droplist.


		//	Call Watchers.

			(function( entity_droplist ){
				entity_droplist.addEventListener( "change", function(){
					this.blur(); callWatchers(this, "onchange", "change", this.value ); // important!
				});
			})( document.querySelector("select#editor-entities-droplist") ); // entity_droplist.

		</script>

		<script>

		//	rigid-object-helpers.js

			const rigidObjects = []; // cameraControls.rigidObjects;

			function addtoRigidObjects( value ){
				var id = parseInt(value);
				if ( !checkId( value ) ) return;
				if ( localPlayer.getObjectById(id) ) return; // localPlayer child.
				var object = getObjectByEntityId( value );
				if ( object && rigidObjects.findIndex( function( item ){ 
					return item.id === object.id;
				}) > -1 ) return; // already exists in rigidObjects.
				object && object.isMesh && rigidObjects.push( object );
			}

			function removefromRigidObjects( value ){
				var index = rigidObjects.findIndex( 
					function( object ){
						return object.id === parseInt( value );
					});
				if ( index < 0 ) return; // important!
				rigidObjects.splice( index, 1 );
			}

		</script>

		<script>

		//	octree-helpers.js

			function addtoOctree( value ){

			//	DevNote: You have to add all objects with the 
			//	same geometry.uuid. 
			//	READ explanation at removefromOctree comments.

				var object = getObjectByEntityId( value );

				if ( !object ) return;
				if ( !object.isMesh ) return;
				if ( !object.geometry ) return;
				if ( !object.geometry.isGeometry ) return;
				if ( localPlayer.getObjectById(object.id) ) return; // localPlayer child.

			//	Import to octree.
			//	octree.importThreeMesh( object );
			//	Import all objects with same geometry to octree.
			//	READ explanation at removefromOctree() comments.
				var uuid = object.geometry.uuid;
				var meshes = getObjectsByGeometry(uuid);
				while ( meshes.length ) {
					octree.importThreeMesh( meshes.shift() );
				}

				return object; // important!
			}

			function removefromOctree( value ){
			//	Removes from octree all objects (geometry
			//	faces) that have the same geometry.uuid.
			//	DevNote: It would be better if was using
			//	mesh.uuid and not geometry.uuid. (TODO).

				var object = getObjectByEntityId( value );

				if ( !object ) return;
				if ( !object.isMesh ) return;
				if ( !object.geometry ) return;
				if ( !object.geometry.isGeometry ) return;

			//	Remove from octree.
			//	DevNote: removes all object's geometry 
			//	faces that have same geometry.uuid.
				var uuid = object.geometry.uuid;
				uuid && octree.removeThreeMesh( uuid );

				return object; // important!
			}

			function updateOctree( value ){
				var object = removefromOctree( value );

				if ( !object ) return;
				if ( !object.isMesh ) return;
				if ( !object.geometry ) return;
				if ( !object.geometry.isGeometry ) return;
				if ( localPlayer.getObjectById(object.id) ) return; // localPlayer child.

			//	Import to octree. 
			//	octree.importThreeMesh( object );
			//	Use addtoOctree() to import to octree.
			//	READ explanation at removefromOctree() comments.
				addtoOctree( value ); 

			}

		//	renamed from "octreeIncluded" to "octreeIncludes".
			function octreeIncludes( uuid ){
				var result;
				octree.nodes.forEach(function (nodeDepth) {
					if ( result ) return;
					nodeDepth.forEach(function (node) {
						if ( result ) return;
						node.trianglePool.forEach(function (face) {
							if ( result ) return;
							if (face.meshID === uuid) result = true;
						});
					});
				});
				return result;
			}

		</script>

		<script>

		//	geometry-create-button.js

			(function(create_button,type_droplist,entity_droplist,material_manager,entity_manager,scene){

				var interval;

				create_button.addEventListener( "click", function(){
					clearTimeout( interval );
					interval = setTimeout(function(){
						callWatchers( create_button, "onclick", "click", type_droplist.value );
					}, 250);
				});

				watch( create_button, "onclick", function( prop, event, type ){

				//	Get type.
					if ( type === "" || type === undefined ) return;

				//	Create geometry.
					var geometry = new THREE[ type ]();
					if ( geometry === undefined ) return;

				//	Init params based on type.
					switch (type) {
						case "PlaneGeometry":
							geometry.translate(0, 0.5, 0);
						break;
					//	case "BoxGeometry":
					//	case "ConeGeometry":
					//	case "TorusGeometry":
					//	case "SphereGeometry":
					//	case "CylinderGeometry":
					//	case "OctahedronGeometry":
					//	case "DodecahedronGeometry":
					//	case "IcosahedronGeometry":
					//	case "TetrahedronGeometry":
					//	case "TorusKnotGeometry":
					//	case "CircleGeometry":
					//	case "RingGeometry":
					//	break;
					}

				//	Create mesh.
					var material = new THREE.MeshLambertMaterial({side:2});
					var mesh = new THREE.Mesh(geometry, material);
					mesh.name = type.replace("Geometry","");
					scene.add( mesh );

				//	Add entities.
					entity_manager && entity_manager.add( mesh );
					material_manager && material_manager.add( material );

				//	Enter edit mode.
					entity_droplist.value = String(mesh.id);
				});

			})(
				document.querySelector("div#geometry-create-button"), // create_button,
				document.querySelector("select#geometry-type-droplist"), // type_droplist,
				document.querySelector("select#editor-entities-droplist"), // entity_droplist,
				material_entities, entities, scene  // material_manager, entity_manager, scene.
			);

		//	geometry-clone-button.js

			(function(clone_button,entity_droplist,entity_manager,scene){

				var interval;

				clone_button.addEventListener( "click", function(){
					clearTimeout( interval );
					interval = setTimeout(function(){
						callWatchers( clone_button, "onclick", "click", entity_droplist.value );
					}, 250);
				});

				watch( clone_button, "onclick", function( prop, event, value ){

					if ( value === undefined || value === "" ) return;

				//	Get source.
					var source = getObjectByEntityId( Number(value) ); // id.
					if ( !(source && source.isMesh && source.geometry) ) return;

				//	Clone source.
					if ( source.isMesh && source.geometry ) {
					//	clone.
						var mesh = source.clone();
					//	rename.
						if ( source.name ) 
							mesh.name = source.name.replace(/:clone/g,"") + ":clone";
						else
							mesh.name = mesh.type.replace(/Geometry/g,"") + ":clone";
					//	translate.
						mesh.position.y += 1; // (m)
					//	add to scene.
						scene.add( mesh );
					//	add to entities.
						entity_manager.add( mesh );
					//	enter to edit mode.
						entity_droplist.value = String(mesh.id);
					}

				});

			})(
				document.querySelector("div#geometry-clone-button"), // clone_button,
				document.querySelector("select#editor-entities-droplist"), // entity_droplist,
				entities, scene // last_entity, entity_manager, scene.
			);

		//	geometry-remove-button.js

			(function(remove_button,entity_droplist,entity_manager,octree,scene){

				var interval;

				remove_button.addEventListener( "click", function(){
					clearTimeout( interval );
					interval = setTimeout(function(){
						callWatchers( remove_button, "onclick", "click", entity_droplist.value );
					}, 250);
				});

				watch( remove_button, "onclick", function( prop, event, value ){

					if ( value === undefined || value === "" ) return;

					var object = getObjectByEntityId( Number(value) ); 
					if ( !object ) return entity_droplist.value = "";

				//	remove octree.
					if ( object.isMesh && object.geometry ) (function(){
						var uuid = object.geometry.uuid;
						octreeIncludes( uuid ) && octree.removeThreeMesh( uuid );
					})();

				//	remove object.
					object.parent && object.parent.remove( object );

				//	remove entity and option.
					entity_manager && entity_manager.remove( value );

				//	Remove from camera rigid objects.
					removefromRigidObjects( Number(value) ); // id.

				//	Exit edit mode.
					entity_droplist.value = "";

				});

			})(
				document.querySelector("div#geometry-remove-button"), // remove_button,
				document.querySelector("select#editor-entities-droplist"), // entity_droplist,
				entities, octree, scene // entity_manager, scene.
			);

		</script>

		<script>

		//	octree-add-button.js

			(function(add_button,entity_droplist,octree,scene){

				var interval;

				add_button.addEventListener( "click", function(){
					clearTimeout( interval );
					interval = setTimeout(function(){
						callWatchers( add_button, "onclick", "click", entity_droplist.value );
					}, 250);
				});

				watch( add_button, "onclick", function( prop, event, value ){

				//	DevNote: You have to add all objects with the 
				//	same geometry.uuid. 
				//	READ explanation at removefromOctree comments.

					var object = getObjectByEntityId( value );

					if ( !object ) return;
					if ( !object.isMesh ) return;
					if ( !object.geometry ) return;
					if ( !object.geometry.isGeometry ) return;
					if ( localPlayer.getObjectById(object.id) ) return; // localPlayer child.

				//	Import to octree.
				//	octree.importThreeMesh( object );
				//	Import all objects with same geometry to octree.
				//	READ explanation at removefromOctree() comments.
					var uuid = object.geometry.uuid;
					var meshes = getObjectsByGeometry(uuid);
					while ( meshes.length ) {
						octree.importThreeMesh( meshes.shift() );
					}

				});

			})(
				document.querySelector("div#octree-add-button"), // clone_button,
				document.querySelector("select#editor-entities-droplist"), // entity_droplist,
				octree, scene // octree, scene.
			);

		//	octree-remove-button.js

			(function(remove_button,entity_droplist,octree,scene){

				var interval;

				remove_button.addEventListener( "click", function(){
					clearTimeout( interval );
					interval = setTimeout(function(){
						callWatchers( remove_button, "onclick", "click", entity_droplist.value );
					}, 250);
				});

				watch( remove_button, "onclick", function( prop, event, value ){

				//	Removes from octree all objects (geometry
				//	faces) that have the same geometry.uuid.
				//	DevNote: It would be better if was using
				//	mesh.uuid and not geometry.uuid. (TODO).

					var object = getObjectByEntityId( value );

					if ( !object ) return;
					if ( !object.isMesh ) return;
					if ( !object.geometry ) return;
					if ( !object.geometry.isGeometry ) return;

				//	Remove from octree.
				//	DevNote: removes all object's geometry 
				//	faces that have same geometry.uuid.
					var uuid = object.geometry.uuid;
					uuid && octree.removeThreeMesh( uuid );

				});

			})(
				document.querySelector("div#octree-remove-button"), // clone_button,
				document.querySelector("select#editor-entities-droplist"), // entity_droplist,
				octree, scene //  octree, scene.
			);

		</script>

		<script>

		//	camera-controls-add-button.js

			(function(add_button,entity_droplist,cameraControls){

				var interval;

				add_button.addEventListener( "click", function(){
					clearTimeout( interval );
					interval = setTimeout(function(){
						callWatchers( add_button, "onclick", "click", entity_droplist.value );
					}, 250);
				});

				watch( add_button, "onclick", function( prop, event, value ){

					var object = getObjectByEntityId( value );
					var rigidObjects = cameraControls.rigidObjects;

					if ( object && rigidObjects.findIndex( function( item ){ 
						return item.id === object.id;
					}) > -1 ) return; // already exists in rigidObjects.
					object && object.isMesh && rigidObjects.push( object );
				});

			})(
				document.querySelector("div#rigid-add-button"), // clone_button,
				document.querySelector("select#editor-entities-droplist"), // entity_droplist,
				cameraControls // camera_controls.
			);

		//	camera-controls-remove-button.js

			(function(remove_button,entity_droplist,cameraControls){

				var interval;

				remove_button.addEventListener( "click", function(){
					clearTimeout( interval );
					interval = setTimeout(function(){
						callWatchers( remove_button, "onclick", "click", entity_droplist.value );
					}, 250);
				});

				watch( remove_button, "onclick", function( prop, event, value ){

					var object = getObjectByEntityId( value );
					var rigidObjects = cameraControls.rigidObjects;
					var index = rigidObjects.findIndex( 
						function( object ){
							return object.id === parseInt( value );
						});
					if ( index < 0 ) return; // important!
					rigidObjects.splice( index, 1 );
				});

			})(
				document.querySelector("div#rigid-add-button"), // clone_button,
				document.querySelector("select#editor-entities-droplist"), // entity_droplist,
				cameraControls // camera_controls.
			);

		</script>

		<script>














		</script>

		<script>

			TabUI.Editor.role.classList.add("active");
			TabUI.Editor.tab.classList.add("in","active");
			groundHelper.visible = !groundHelper.visible; 
			entities.add(groundHelper);

			cameraControls.setLatLon(5.128, 270.675);
			localPlayer.controller.movementSpeed = 30;
			localPlayer.controller.center.set(-85,2,-2);


		</script>

		<script>

		//	Background.

			(function(scene,textures_entities){

				if (!scene || Number(THREE.REVISION) < 78) return;

				var urls = [
					"https://i.imgur.com/v6bjQLb.jpg", // "posx.jpg",
					"https://i.imgur.com/lwrlr6P.jpg", // "negx.jpg", 
					"https://i.imgur.com/kKUKBJg.jpg", // "posy.jpg", 
					"https://i.imgur.com/N0oZlJR.jpg", // "negy.jpg", 
					"https://i.imgur.com/x9q8z0K.jpg", // "posz.jpg", 
					"https://i.imgur.com/HYcK7Ii.jpg", // "negz.jpg"
				];

				var loader = new THREE.CubeTextureLoader();
				loader.setCrossOrigin( "anonymous" );
				loader.load( urls, function(texture){
					scene.background = texture;
					scene.background.needsUpdate = true;
					textures_entities && textures_entities.add(texture);
				});

			})( scene, textures_entities );

		</script>

		<script>

		//  Skydome.

			const skydome = (function(scene,entities,material_entities,textures_entities){

				var loader = new THREE.TextureLoader();
				loader.setCrossOrigin( "anonymous" );
				var geometry = new THREE.SphereGeometry( 2000, 64, 32 );
				var texture = loader.load( "https://i.imgur.com/xQsNP0X.jpg" );
				texture.wrapS = texture.wrapT = 1000; texture.offset.y = -0.01;
				var material = new THREE.MeshBasicMaterial({
					map:texture,transparent:true,opacity:0.8,side:1,
				});
				var dome = new THREE.Mesh( geometry, material );
				dome.scale.set(0.10,0.08,0.10); dome.name = "skydome";
				scene.add(dome); entities && entities.add(dome);
				textures_entities && textures_entities.add(texture);
				material_entities && material_entities.add(material);
				return dome;

			})(scene, entities, material_entities, textures_entities);

		</script>

		<script>

		//  Water.

			const water = (function(renderer,camera,scene,light,textures_entities){

				var waterNormals = loadTexture("/tradecenter/textures/waternormals.jpg");
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;
				textures_entities && textures_entities.add(waterNormals);

			//  the water effect.
				return new THREE.Water(renderer, camera, scene, {
					textureWidth:256,  textureHeight:256,
					waterNormals:waterNormals, alpha:0.9,
					sunDirection:light.position.normalize(),
					sunColor:0xffffff,  waterColor:0x001e0f,
					betaVersion:0, side:2,
				});

				function loadTexture( url, mapping) {
					var loader = new THREE.TextureLoader();
					loader.setCrossOrigin( "anonymous" );
					var texture = loader.load( url );
					if ( mapping ) texture.mapping = mapping;
					return texture;
				}

			})( renderer, camera, scene, cameraLight, textures_entities );

			const watermirror = (function( scene,water,material_entities,entities ){

				material_entities && material_entities.add(water.material);
				var material = water.material; entities && entities.add(water); 
				var geometry = new THREE.PlaneBufferGeometry(10000, 10000, 100, 100);
				var mirror = new THREE.Mesh( geometry, material );
				mirror.add(water); mirror.name = "water mirror";
				mirror.rotation.x = -Math.PI/2;
				mirror.position.y = -0.01;
				scene.add(mirror);

				var clock = new THREE.Clock();
				(function render(){
					var dt = clock.getDelta();
					requestFrameID = requestAnimationFrame( render );
					water.material.uniforms.time.value += Math.max(dt, 1/60);
					water.render();
				})();

				return mirror;

			})( scene, water, material_entities, entities );

		</script>

		<script>

		//	Water path.

			(function(scene,octree,cameraControls,entities){
				var w=2.5, h=0.5, d=200, x=-85, y=-h/2, z=100;
				var geometry = new THREE.BoxGeometry(w,h,d);
				geometry.translate(0, h/2, 0);
				var material = new THREE.MeshLambertMaterial();
				var mesh = new THREE.Mesh(geometry, material);
				mesh.name = "water path";
				mesh.position.set(x,y,z);
				scene.add( mesh );
			//	var geometry = new THREE.EdgesGeometry( geometry );
			//	var segments = new THREE.LineSegments( geometry, material );
			//	segments.name = "water path edges";
			//	segments.position.copy( mesh.position );
			//	octree.importThreeMesh( mesh );
				entities && entities.add( mesh );
			//	cameraControls.rigidObjects.push( mesh );
			//	return mesh;
			})( scene, octree, cameraControls, entities );

		</script>

		<script>

		//	deck 0.

			(function(scene,octree,cameraControls,entities){
				var w=110, h=0.5, d=60, x=-2, y=-h/2, z=2.6;
				var geometry = new THREE.BoxGeometry(w,h,d);
				geometry.translate(0, h/2, 0);
				var material = new THREE.MeshLambertMaterial();
				var mesh = new THREE.Mesh(geometry, material);
				mesh.name = "deck0";
				mesh.position.set(x,y,z);
				scene.add( mesh );
			//	var geometry = new THREE.EdgesGeometry( geometry );
			//	var segments = new THREE.LineSegments( geometry, material );
			//	segments.name = "water path edges";
			//	segments.position.copy( mesh.position );
			//	octree.importThreeMesh( mesh );
				entities && entities.add( mesh );
			//	cameraControls.rigidObjects.push( mesh );
			//	return mesh;
			})( scene, octree, cameraControls, entities );

			(function(scene,octree,cameraControls,entities){
				var w=100, h=0.5, d=50, x=-2, y=-0, z=2.6;
				var geometry = new THREE.BoxGeometry(w,h,d);
				geometry.translate(0, h/2, 0);
				var material = new THREE.MeshLambertMaterial();
				var mesh = new THREE.Mesh(geometry, material);
				mesh.name = "deck0 floor";
				mesh.position.set(x,y,z);
				scene.add( mesh );
			//	var geometry = new THREE.EdgesGeometry( geometry );
			//	var segments = new THREE.LineSegments( geometry, material );
			//	segments.name = "water path edges";
			//	segments.position.copy( mesh.position );
			//	octree.importThreeMesh( mesh );
				entities && entities.add( mesh );
			//	cameraControls.rigidObjects.push( mesh );
			//	return mesh;
			})( scene, octree, cameraControls, entities );













		</script>

	</body>
</html>
